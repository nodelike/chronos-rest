// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String   @id @default(uuid())
  email         String   @unique
  username      String?
  password      String
  isVerified    Boolean  @default(false)
  verificationCode String?
  verificationCodeExpires DateTime?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@map("users")
}

model Utils {
  id        String   @id @default(uuid())
  name      String   @unique
  data      Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("utils")
}

// Enums
enum ChronicleItemType {
  PHOTO
  VIDEO
  DOCUMENT
  AUDIO
  EVENT
  NOTE
  LOCATION
  LINK
  SOCIAL_MEDIA
  OTHER
}

enum CollectorType {
  EVENT_BASED
  PERIODIC
  MANUAL
}

enum SocialPlatform {
  TWITTER
  INSTAGRAM
  LINKEDIN
  OTHER
}

enum PersonRelationType {
  FRIEND
  COLLEAGUE
  FAMILY
  FOLLOWER
  OTHER
}

// Storage Unit: Raw & Enriched Media
model StorageItem {
  id              String           @id @default(uuid())
  uri             String
  fileName        String
  fileSize        Int
  mimeType        String
  type            ChronicleItemType
  source          String           // camera, twitter, linkedin, calendar, etc.
  collectorType   CollectorType    @default(MANUAL)
  userId          String

  createdAt       DateTime         @default(now())
  processedAt     DateTime?

  rawMetadata     Json?            // EXIF, calendar ICS, tweet payload, etc.

  // sub-model enrichment
  geoMeta         GeoMeta?         @relation(fields: [geoMetaId], references: [id])
  geoMetaId       String?          @unique

  ocrMeta         OcrMeta?         @relation(fields: [ocrMetaId], references: [id])
  ocrMetaId       String?          @unique

  transcriptMeta  TranscriptMeta?  @relation(fields: [transcriptMetaId], references: [id])
  transcriptMetaId String?         @unique

  keywordMeta     KeywordMeta?     @relation(fields: [keywordMetaId], references: [id])
  keywordMetaId   String?          @unique

  // New relationships for additional AWS Rekognition features
  labelMeta       LabelMeta?       @relation(fields: [labelMetaId], references: [id])
  labelMetaId     String?          @unique

  customLabelMeta CustomLabelMeta? @relation(fields: [customLabelMetaId], references: [id])
  customLabelMetaId String?        @unique
  
  contentModerationMeta ContentModerationMeta? @relation(fields: [contentModerationMetaId], references: [id])
  contentModerationMetaId String?  @unique

  faceDetections  FaceDetection[]

  // Used as profile pictures for Person - one-to-one relation
  profileFor      Person?
  socialMetas     SocialMeta[]     
  chronicles      Chronicle[]      @relation("ChronicleStorageRefs")

  @@index([type])
  @@index([processedAt])
  @@map("storage_items")
}

// Individual metadata types
model GeoMeta {
  id        String      @id @default(uuid())
  lat       Float
  lng       Float
  place     String?
  storageItem StorageItem?

  @@map("geo_meta")
}

model OcrMeta {
  id        String      @id @default(uuid())
  text      String
  language  String?
  rawMetadata Json?     // Store structured OCR data (blocks, lines, words, etc.)
  storageItem StorageItem?

  @@map("ocr_meta")
}

model TranscriptMeta {
  id        String      @id @default(uuid())
  transcript String
  language   String?
  storageItem StorageItem?

  @@map("transcript_meta")
}

model KeywordMeta {
  id        String      @id @default(uuid())
  keywords  String[]
  storageItem StorageItem?

  @@map("keyword_meta")
}

// New models for additional AWS Rekognition features

model LabelMeta {
  id            String      @id @default(uuid())
  labels        Json        // Array of labels with confidence scores
  dominantColors Json?      // Color information
  imageQuality  Json?       // Quality metrics
  storageItem   StorageItem?

  @@map("label_meta")
}

model CustomLabelMeta {
  id            String      @id @default(uuid())
  customLabels  Json        // Custom objects detected with confidence
  modelVersion  String?     // The version of custom labels model used
  storageItem   StorageItem?

  @@map("custom_label_meta")
}

model ContentModerationMeta {
  id               String      @id @default(uuid())
  moderationLabels Json        // Detected moderation labels
  moderationConfidence Float?  // Overall moderation confidence
  isSafe           Boolean     @default(true)
  storageItem      StorageItem?

  @@map("content_moderation_meta")
}

// Each detected face instance links a StorageItem to a Person
model FaceDetection {
  id              String     @id @default(uuid())
  confidence      Float      // 0.0â€“1.0
  boundingBox     Json?      // optionally store { x, y, width, height }
  storageItem     StorageItem @relation(fields: [storageItemId], references: [id])
  storageItemId   String
  person          Person     @relation(fields: [personId], references: [id])
  personId        String
  createdAt       DateTime   @default(now())

  @@map("face_detections")
}

// A canonical person in your system
model Person {
  id                  String             @id @default(uuid())
  name                String
  aliases             String[]
  isCelebrity         Boolean           @default(false)
  celebrityInfo       Json?             // Store URLs, profession, and other celebrity-specific data

  profilePicture      StorageItem?       @relation(fields: [profilePictureId], references: [id])
  profilePictureId    String?            @unique

  socialProfiles      SocialProfile[]

  faceDetections      FaceDetection[]

  relationsFrom       PersonRelation[]   @relation("RelationFrom")
  relationsTo         PersonRelation[]   @relation("RelationTo")

  createdAt           DateTime           @default(now())
  updatedAt           DateTime           @updatedAt

  @@map("people")
}

// Link two People together (friend, colleague, etc.)
model PersonRelation {
  id               String             @id @default(uuid())
  fromPerson       Person             @relation("RelationFrom", fields: [fromId], references: [id])
  fromId           String
  toPerson         Person             @relation("RelationTo", fields: [toId], references: [id])
  toId             String
  type             PersonRelationType
  createdAt        DateTime           @default(now())

  @@map("person_relations")
}

// The real person's account on a social platform
model SocialProfile {
  id               String         @id @default(uuid())
  platform         SocialPlatform
  handle           String         // e.g. "@jane_doe"
  profileUrl       String
  bio              String?
  person           Person         @relation(fields: [personId], references: [id])
  personId         String
  posts            SocialMeta[]

  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt

  @@map("social_profiles")
}

model SocialMeta {
  id                String           @id @default(uuid())
  platform          SocialPlatform
  postUrl           String
  content           String
  hashtags          String[]
  postedAt          DateTime         @default(now())
  authorProfile     SocialProfile?   @relation(fields: [authorProfileId], references: [id])
  authorProfileId   String?

  attachments       StorageItem[]

  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt

  @@map("social_meta")
}

// Chronicle: The narrative + embedded references
model Chronicle {
  id            String         @id @default(uuid())
  title         String
  description   String?
  tags          String[]
  startDate     DateTime?
  endDate       DateTime?
  userId        String

  body          Json           // markdown or portable text with embedded StorageItem IDs
  
  referencedStorageItems StorageItem[] @relation("ChronicleStorageRefs")

  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt

  @@index([title])
  @@index([tags])
  @@index([startDate, endDate])
  @@map("chronicles")
}
